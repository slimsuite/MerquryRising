---
title: "Merqury Rising: Kmer-based QV Assessment"
author: "Richard J. Edwards"
date: "01/11/2023"
version: "v0.2.0"
output:
  html_document:
    #css: http://www.slimsuite.unsw.edu.au/stylesheets/slimhtml.css
    toc: true
    toc_float: true
    toc_collapsed: false
    toc_depth: 3
    number_sections: true
---

# Introduction

[MerquryRising](https://github.com/slimsuite/MerquryRising) is a standalone RMarkdown file for parsing outputs from [Merqury](https://github.com/marbl/merqury) and generating some additional plots to help assess the requirements and/or consequences of duplicate purging in genome assemblies. Please see the accompanying [Tutorial.html](./Tutorial.html) for additional information about the rationale behind the program and its features. The GitHub README will also contain some information about running the script. If you are not getting the outputs you expect, please check or update the `merquryrising.config` configuration file, consisting of tab-delimited pairs of `setting` and `value`. 

The Merqury files needed are:

* A set of `*.spectra-cn.hist` files of read and assembly kmer counts.
* A corresponding set of `*.only.hist` files of assembly-only kmer counts.
* An optional read kmer `*.hist.ploidy` file given with `ploidyfile=FILE`. If this is a `*.hist` file, this will be used to set all the boundaries.

Input files are read from the directory specified by `merqurydir=PATH` (default:`merqury`) and are set by `histfiles=X` (wildcards allowed, default:`*.spectra-cn.hist`). A matching set of `*.only.hist` files are also expected. Human-friendly labels can be provided with a `merquryrising.fofn` file (`labels=FILE`) that consists of `label filename` as plain text. `filename` in this instance is the full name of the `*.spectra-cn.hist` file, excluding the path.

1. Default mode will compare each kmer histogram with the preceding one.
2. Reference mode will compare every kmer histogram with the same reference. (Either named, else the first file.)

To check the settings loaded from the config file, edit the Rmarkdown to have `debug=TRUE`.

```{r rmd, echo=FALSE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = FALSE, include = TRUE, warning=FALSE, message=FALSE)
# HISTORY
# v0.1.0 - Initial draft version
# v0.2.0 - Added config file to settings

# TO DO
# [Y] : Implement reading of setting from merquryrising.config.
# [Y] : Need to add aliases for the input files, as these are often very long!
# [ ] : Add output of tables to a tables/ directory, and plots to a plots/ directory?
# [ ] : Partition information between function script (this one) and the Tutorial.Rmd
# [ ] : Rationalise the use of sig fig or dp?
# [ ] : Consider adding direct parsing of the diploid mode output to generate a diploid report. This is a bit tricky though as it does not have the duplications, so maybe haploids versus a separate diploid is better? (Could use the diploid as the reference?)
# [ ] : Add an option to use a density function to calculate the ploidy boundaries rather than the ploidy file. (Needed for multiple different data types.)
# [ ] : Generate a simplified version that processes all the "*.spectra-cn.hist" files and generates the classification tables and plots only.
# [ ] : Scale the plot height according to numbers of assemblies. 
# [ ] : Add a simple version of the Rscript that takes a single hist file as an argument and generates tables and plots. (For now, run the whole thing but with one input!)
# [ ] : Document a simple use-case of providing a pair of assemblies.
# [ ] : Expand the reference selection to enable loading of a file that sets the references: assembly reference (based on the labels)
# [ ] : HARD: Replace simple boundaries with fitted distributions.
# [ ] : Update to process the diploid ASM data with the haplotype-specific and shared kmers.
# [ ] : Add capacity to parse qv and completeness from collated tables and map via name.
# [ ] : Rationalise the dimensions of the output graphics.
# [ ] : Do not generate relative purge plot if no change! Just report a lack of difference. (Tabulate the difference.)

# NOTES
#!# Consider setting results='asis' to avoid wrapping in ```.
#?# I wonder if this is the solution for HTML output within loops?

#i# Set defaults for the Rmd implementation that might be different from the standalone version
override <- c('fullrun=FALSE','rdir=.','debug=TRUE','dev=TRUE')
source('./merquryrising.R')
```

```{r functions, eval=FALSE, include=FALSE}
#i# Now part of the merquryrising.R script.
```

## Merqury Rising workflow

The general `MerquryRising` workflow is as follows:

- Run Merqury.
- Establish list of input assembly files and build alias list (`G1` to `Gn`).
- Load the read kmer frequency boundaries from the ploidy file: `ploidy`, `depth`, `boundary`.
- Load the `*.spectra-cn.hist` data tables into tibbles with 3 fields: `afreq` (kmer frequency in assembly), `rfreq` (kmer frequency in reads) and `knum` (number of different kmers).
- Convert the `read-only` kmers into `0` and make sure all fields are integers.
- Add the `*.only.hist` data to each table.
- Join all the count tables by `afreq` and `rfreq` to give a field per input file. (`G1` to `Gn`). [`Table1`]
- Convert `Table1` into a version of all values relative to reference. [`Table2`]
- Convert `Table1` into a long version [`Table3`] -> `knum` and `assembly`.
- Convert `Table3` `rfreq` into categories based on `ploidy`: `low`, `hap`, `dip`, `high`.
- Create a `Table3` `class` field, based on `afreq` and `rfreq` (see below)
- Collapse by `class` and sum up the `knum`
- Create a `Table4` from `Table3` with the `purge` categories (see below)
- Generate a horizontal stacked bar plot of each assembly: noise, only, lowQ, duplicate, alternate, haploid, diploid, repeats, collapsed, missing [`Table3`]
- Generate a horizontal stacked bar plot of each assembly: noise, only, under, good, over [`Table4`]
- Generate a kmer difference plot for each assembly versus the reference with afreq of 0, 1, 2, 3+ [`Table2`]
- Reshape `Table3` and `Table4` wide and convert into difference versus reference. Generate difference plots.

**NOTE:** The `only` class could indicate assembly errors, or it could indicate missing kmers due to sequencing biases. As such, they are excluded from the classification, as are the `noise` kmers, which are suspected read errors or contamination.

Please see the Tutorial for more details.

### Kmer classes

Kmer classes will be assigned based on the read frequency (`rfreq`) and kmer frequency (`kfreq`), ploidy boundaries (see Tutorial and below), and whether the assembly is haploid or diploid. Classification is first based on more specific categories, which are then grouped into broader purge categories. The `dipclass` and `dippurge` ratings are used for diploid assemblies.

_Add table of class and purge descriptions._


```{r dipkmerclasses}
#i# Definition now part of the merquryrising.R script.
kclassdb <- D$kclassdb
kable(D$kclassdb, "html", caption = "MerquryRising Kmer frequency classes.", align = "c") %>% kable_styling("striped", full_width = F)
```


# Input Data

The main input for MerquryRising is the set of `*.spectra-cn.hist` and corresponding `.only.hist` files, with optional `qv/*.merqury.qv` and `stats/*.merqury.completeness.stats` files. The latter are matched on the `name` field, which is parsed from the `*.spectra-cn.hist` and split on `.merqury.`. (See the example data if unclear.)

Optionally, assembly names will be mapped from the `labels=FILE`, otherwise the label will be the "G" number, `G1` to `Gn`.

_Add the field descriptions here_.

## Input files and assemblies

The following input files and assemblies have been recognised for this run:

```{r set_files}
#i# Creation is now handled in the R script.
# adb <- setInputFiles()
adb <- D$adb
#i# Summarise the input data table
if(settings$debug){
  kable(adb, "html", caption = "Input genome assemblies and QV/completeness stats.", align = "l") %>% kable_styling("striped", full_width = F)  
}else{
  kable(adb %>% select(-file,-ofile), "html", caption = "Input genome assemblies and QV/completeness stats.", align = "l") %>% kable_styling("striped", full_width = F)
}
```


## Setting the ploidy boundaries

The next step is set the ploidy boundaries that establish `rfreq` categories as `low`, `haploid`, `diploid` or `high` frequencies. Assembly-only kmers are classified as `only`. 

The original iterations of this script used the `boundary` values loaded from the `ploidy` file, but these appear to be quite conservative and result in a lot of kmers being rated as over- or under-purged based on the merqury plots themselves, with a lot of the main distributions broader than the values loaded. Ploidy boundaries are therefore set by default to be determined from the histograms themselves. For consistent boundaries, provide a `*.hist` file to the `ploidy=FILE` setting.

When `*.hist` files are used (assembly-specific or general), the diploid peak is first identified as the kmer density peak for rfreq values up to 1000. The boundaries are then calculated based on this `diploid` peak:

* `haploid` frequency is set to half `diploid`.
* The `low` boundary is set to the _maximum_ value of 5, or 0.25 `haploid`. Upto this value of `rfreq` (raw read kmer frequency), kmers are rated `low`. This is plotted as a solid black line on the Comparative Merqury plots.
* The `mid` boundary is set to halfway between `haploid` and `diploid`. Raw kmer frequencies above the `low` boundary and upto the `mid` boundary `hap`. This is plotted as a solid red line on the Comparative Merqury plots, with the haploid peak a dotted red line.
* The `high` boundary is set to 1.5 `diploid`. Raw kmer frequencies above the `hap` boundary and upto the `high` boundary are rated `dip`. This is plotted as a solid blue line on the Comparative Merqury plots, with the diploid peak a dotted blue line.
* Above the `high` boundary, kmers are rated as `high`.

**NOTE:** For very heterozygous genomes, where the haploid peak exceeds the diploid peak, the diploid peak calculation will break. For these, it is advised to make and load a `*.ploidy` file to use for all assemblies.

**NOTE:** The classification percentages are ultimately defined by the ploidy boundaries, which do not fully capture the extent of each sub-distribution of kmers. As a consequence, there will always be a degree of mis-assigned kmers. For this reason, percentages are best considered as comparative values rather than absolute values.


```{r load_ploidy}
#i# Optional loading of the ploidy file or generic ploidy boundaries are now handled in the main R script.

if(nrow(D$ploidy) > 0){
  kable(D$ploidy, "html", caption = "Ploidy boundaries for all assemblies, loaded from ploidy file.", align = "l") %>% kable_styling("striped", full_width = F)
}
if(nrow(D$boundary) > 0){
  kable(D$boundary, "html", caption = "Ploidy boundaries for all assemblies.", align = "l") %>% kable_styling("striped", full_width = F)
}
```

## Load and integrate kmer frequency data








## Load hist tables

Generate `Table1` from the hist files.

```{r loadhist}
# - Load the `*.spectra-cn.hist` data tables into tibbles with 3 fields: `afreq` (kmer frequency in assembly), `rfreq` (kmer frequency in reads) and `knum` (number of different kmers).
Tab1 <- D$Tab1 #makeTab1()  #i# Main code moved to the Rscript.

#!# This has broken the boundary table generation: need to fix
# Put D within the function and then return D with D$Tab1 and D$boundary

# Display boundaries loaded from the individual distributions
if(nrow(D$boundary) > 0){
  kable(D$boundary, "html", caption = "Ploidy boundaries.", align = "l") %>% kable_styling("striped", full_width = F)
}

adb <- D$adb
boundary <- D$boundary
ploidy <- D$ploidy

```



# Processing


### Reference-normalised scores

Generate `Table2` from `Table1`, with all values relative to reference.


```{r Table2}
# - Convert `Table1` into a version of all values relative to reference. [`Table2`]
#i# If settings$reference is `default`, will use the previous genome as the reference in each case
#i# Otherwise, will compare all to a specific reference
if(settings$reference %in% adb$name){
  refG <- adb[settings$reference == adb$name,]$G
}else{
  if(settings$reference != "default"){
    logWrite(paste("Cannot find reference:",settings$reference))
  }
  #!# Add option to use a number to pick the reference
}
Tab2 <- Tab1
prevG <- adb$G[1]
for(G in adb$G){
  if(settings$reference == "default"){
    refG <- prevG
    prevG <- G
  }
  Tab2[[G]] <- Tab1[[G]] - Tab1[[refG]]
}
```

At this point, we have two "wide" tables of the kmer counts for each genome that belong to different assembly (`afreq`) and raw (`rfreq`) frequency classes. `Table1` has absolute values, whilst `Table2` has values relative to the reference. 


### Classification table

Generate `Table3`. This is a "long" version of Table 1, with the addition of a `knum` field. `afreq` and `rfreq` are then converted to the categories based on `afreq` and ploidy. Assembly-only kmers are arbitrarily given haploid or diploid kmer frequencies for the purposes of calculating the total kmer percentage for these categories.

```{r Table3}
#!# Update this to join with a boundaries table first to allow different boundaries per assembly, then do the ratings.
#i# Convert into a ploidy table with G hap dip and high boundaries and fields



# - Convert `Table1` into a long version [`Table3`] -> `knum` and `assembly`.
#!# Add report of full ksize and then calculate the %assembly-only and adjust "collapsed"
Tab3 <- Tab1 %>%
  pivot_longer(
    cols = starts_with("G"),
    names_to = "assembly",
    names_prefix = "G",
    values_to = "knum"
  ) %>% mutate(assembly = as.integer(assembly))
# - Convert `Table3` `rfreq` into categories based on `ploidy`: `low`, `hap`, `dip`, `high`.
if("*" %in% boundary$G){
  bi <- rep(1,nrow(Tab3))
}else{
  bi <- Tab3$assembly
}
Tab3$ploidy <- "none"
Tab3[Tab3$rfreq > 0,]$ploidy <- "low"
Tab3[Tab3$rfreq > boundary$low[bi],]$ploidy <- "hap"
Tab3[Tab3$rfreq > boundary$mid[bi],]$ploidy <- "dip"
Tab3[Tab3$rfreq > boundary$high[bi],]$ploidy <- "high"
Tab3$ploidy <- ordered(Tab3$ploidy,levels=c("none","low","hap","dip","high"))
# - Create a `Table3` `class` field, based on `afreq` and `rfreq`
Tab3$atype <- "3+"
Tab3[Tab3$afreq < 3,]$atype <- "2"
Tab3[Tab3$afreq < 2,]$atype <- "1"
Tab3[Tab3$afreq < 1,]$atype <- "0"
Tab3$atype <- ordered(Tab3$atype,levels=c("0","1","2","3+"))
# - Generate the kfreq field = knum x rfreq
# - If settings$only=TRUE, will add a fake rfreq according to the ploidy
if(settings$only){
  bhap <- Tab3$afreq == 1 & Tab3$rfreq == 0
  Tab3[bhap,]$rfreq <- boundary$haploid[bi][bhap]
  bdip <- Tab3$afreq == 2 & Tab3$rfreq == 0
  Tab3[bdip,]$rfreq <- boundary$diploid[bi][bdip]
}
Tab3 <- Tab3 %>% 
  group_by(atype,ploidy,assembly) %>%
  summarise(kfreq = sum(knum * rfreq)) %>%
  rename(afreq=atype, rfreq=ploidy) %>%
  left_join(kclassdb)
Tab3$purge <- ordered(Tab3$purge,levels=c("only","n/a","under","good","neutral","over"))
Tab3$class <- ordered(Tab3$class,levels=c("only","noise","lowQ","duplicate","alternate","haploid","diploid","repeats","collapsed","missing"))
Tab3$dippurge <- ordered(Tab3$dippurge,levels=c("only","n/a","under","good","neutral","over"))
Tab3$dipclass <- ordered(Tab3$dipclass,levels=c("only","noise","lowQ","duplicate","alternate","haploid","diploid","repeats","collapsed","missing"))
#!# Update to account for haploid and diploid assemblies
dips <- endsWith(adb$name,"dip") | endsWith(adb$label,"dip")
if(settings$ploidy == "hap"){ dips <- FALSE }
if(settings$ploidy == "dip"){ dips <- TRUE }
if(sum(dips) > 0){
  dipi <- dips[Tab3$assembly]
  Tab3[dipi,]$purge <- Tab3[dipi,]$dippurge
  Tab3[dipi,]$class <- Tab3[dipi,]$dipclass
}
Tab3 <- Tab3 %>% select(-dippurge, -dipclass)
```

`Table3` should now have haploid- and diploid-specific ratings.

```{r palettestuff}

# Define the base colors
green_base <- c("lightgreen", "darkgreen")
blue_base <- c("lightblue", "darkblue")
red_base <- c("lightcoral", "darkred")
# Create palette functions
green_palette <- colorRampPalette(green_base)
blue_palette <- colorRampPalette(blue_base)
red_palette <- colorRampPalette(red_base)
# Generate the colors
green_hues <- green_palette(4)
blue_hues <- blue_palette(4)
red_hues <- red_palette(4)
# Combine the colors into a single palette
mqrcol <- c(blue_hues, green_hues, red_hues)

#i# Update the colour matching for the levels
# - c("only","n/a","under","good","over"))
purgecol <- c(mqrcol[1],"black",mqrcol[2],mqrcol[7],"grey",mqrcol[10])
purgecoldf <- tibble(purge=c("only","n/a","under","good","neutral","over"),
                     purgecol=purgecol)
# - =c("only","noise","lowQ","duplicate","alternate","haploid","diploid","repeats","collapsed","missing")
classcol <- mqrcol[c(1:9,11)]
classcoldf <- tibble(class=c("only","noise","lowQ","duplicate","alternate","haploid","diploid","repeats","collapsed","missing"),
                     classcol=classcol)

# Create a data frame with the colors of the palette
colors_df <- data.frame(
  color = c(blue_hues, green_hues, red_hues)
)
# Create a ggplot object
p <- ggplot(colors_df, aes(x = rep(1:4,3), y = c(1,1,1,1,2,2,2,2,3,3,3,3), fill = color)) +
  geom_tile() +
  scale_fill_identity() +
  theme_void() +
  theme(legend.position = "none")
#print(p)


```

# Results

## Purge classification plots



```{r Table4, fig.width=6, fig.height=3}
# - Create a `Table4` from `Table3` with the `purge` categories (see below)
Tab4 <- Tab3 %>%
  select(-class) %>%
  group_by(purge,assembly) %>%
  summarise(kfreq = sum(kfreq)) %>%
  group_by(assembly) %>%
  mutate(percentage = (kfreq / sum(kfreq)) * 100) 

#Tab4$G <- ordered(adb$G[Tab4$assembly],levels=rev(adb$G))
Tab4$G <- ordered(adb$label[Tab4$assembly],levels=rev(adb$label))

kable(Tab4 %>% mutate(percentage = num(percentage, sigfig = 3)) %>%
        pivot_wider(id_cols = G, names_from = purge, values_from = percentage) %>%
        left_join(adb %>% select(label,completeness,qv) %>% rename(G=label)) %>%
        rename(assembly=G),
      "html", caption = "Simplified purge classifiers.", align = "l") %>% kable_styling("striped", full_width = F)

#!# Add the QV and Completeness scores to this table

Tab4$purge2 <- ordered(Tab4$purge,levels=rev(c("only","n/a","under","over","neutral","good")))
purgecol2 <- purgecol[c(1:3,6,5,4)]

p <- ggplot(Tab4, aes(x = percentage, y = G, fill = purge2)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = rev(purgecol2)) +
  labs(x = "Percentage", y = "Assembly") +
  theme_minimal()
print(p)


Tab4$purge <- ordered(Tab4$purge,levels=rev(levels(Tab4$purge)))

#Tab4 <- Tab4 %>% left_join(purgecoldf)

p <- ggplot(Tab4, aes(x = percentage, y = G, fill = purge)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = rev(purgecol)) +
  labs(x = "Percentage", y = "Assembly") +
  theme_minimal()
print(p)




# - Collapse by `class` and sum up the `knum` [`Table5`]
Tab5 <- Tab3 %>%
  select(-purge) %>%
  group_by(class,assembly) %>%
  summarise(kfreq = sum(kfreq)) %>%
  group_by(assembly) %>%
  mutate(percentage = (kfreq / sum(kfreq)) * 100) 

#Tab5$G <- ordered(adb$G[Tab5$assembly],levels=rev(adb$G))
Tab5$G <- ordered(adb$label[Tab5$assembly],levels=rev(adb$label))
Tab5$class <- ordered(Tab5$class,levels=rev(levels(Tab5$class)))
p <- ggplot(Tab5, aes(x = percentage, y = G, fill = class)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = rev(classcol)) +
  labs(x = "Percentage", y = "Assembly") +
  theme_minimal()
print(p)

# Considered sigfig=3 but digits=2 is probably more useful
kable(Tab5 %>% mutate(percentage = num(percentage, digits = 2)) %>%
  pivot_wider(id_cols = G, names_from = class, values_from = percentage) %>%
  rename(assembly=G), "html", caption = "Purge classifiers.", align = "l") %>% kable_styling("striped", full_width = F)


# [ ] Save to PDF
# pdfwidth <- settings$pdfwidth
# pdfheight <- 1 + 2*length(settings$order)


#!# Add the "only" numbers

#Q# How should the only kmers be handled? Nominally, each assembly-only kmer should be present at the diploid read depth?

#?# Should the repeats be "neutral"?
#!# Add a second plot without repeats

# - Generate a horizontal stacked bar plot of each assembly: noise, only, lowQ, duplicate, alternate, haploid, diploid, repeats, collapsed, missing [`Table5`]
# - Generate a horizontal stacked bar plot of each assembly: noise, only, under, good, over [`Table4`]

# - Generate a kmer difference plot for each assembly versus the reference with afreq of 0, 1, 2, 3+ [`Table2`]


# - Reshape `Table5` and `Table4` wide and convert into difference versus reference. Generate difference plots.

```





```{r merquryPlot}
#i# This has been moved to the Rscript
```

## Comparative Merqury plots

These plots have been converted into relative values compared to the reference assembly. The reference assembly will have the full Merqury plot. Note that the read-only kmers (`afreq`=0) may be truncated.

```{r plotsVsRef, results='asis'}

for(i in 1:nrow(adb)){
  pref = FALSE
  pTab <- Tab2
  ytitle <- "kmer count shift" 
  if(settings$reference == "default"){
    if(i < 2){
      pref <- TRUE
    }
    refname <- adb$name[i-1]
  }
  if(settings$reference == adb$name[i]){
    pref <- TRUE
  }
  if(settings$reference %in% adb$name){
    refname <- settings$reference
  }
  if(pref){
    pTab <- Tab1 #%>% filter(rfreq > 1)
    ytitle <- "No. distinct kmers"
  }
  G <- adb$G[i]
  dat <- pTab %>% rename(knum=!!G) %>% select(afreq,rfreq,knum)
  p <- merquryPlot(dat,ytitle,G)
  cat(paste('###',adb$name[i],'\n\n'))
  
  print(kable(adb[i,], "html", caption = adb$name[i], align = "l") %>% kable_styling("striped", full_width = F))
  cat(paste('\n\n'))
  if(! pref){
    cat(paste0('\n\nRelative change of ',adb$name[i],' versus ',refname,':\n\n'))
  }else{
    cat(paste0('\n\nMerqury plot for ',adb$name[i],'.\n\n'))
  }
  print(p)
  #cat(paste0('\n\n**Plot of relative change versus',refname,'.**\n\n'))
  cat('\n\n')
}




```






```{r planning, eval=FALSE, include=FALSE}
#i# Future updates should incorporate BUSCO and DepthKopy (AGRatio) outputs for comparison.


```